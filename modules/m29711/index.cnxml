<document xmlns="http://cnx.rice.edu/cnxml" xmlns:md="http://cnx.rice.edu/mdml">
  <title>Module 7: Microprogramming</title>
  <metadata>
  <md:content-id>m29711</md:content-id><md:title>Module 7: Microprogramming</md:title>
  <md:abstract/>
  <md:uuid>d5fcf747-bef0-45d2-a5eb-13dbbfa2a9d3</md:uuid>
</metadata>

<content>
    <section id="id-985000926049">
      <title>1. Basis Concepts</title>
      <list id="id7541466" list-type="bulleted">
        <item>Micro-operations: We have already seen that the programs are executed as a sequence of instructions, each instruction consists of a series of steps that make up the instruction cycle fetch, decode, etc. Each of these steps are, in turn, made up of a smaller series of steps called micro-operations.</item>
      </list>
      <list id="id8218434" list-type="bulleted">
        <item>Micro-operation execution: Each step of the instruction cycle can be decomposed into micro-operation primitives that are performed in a precise time sequence. Each micro-operation is initiated and controlled based on the use of control signals / lines coming from the control unit.</item>
      </list>
      <para id="id8741835">- Controller the data to move from one register to another</para>
      <para id="id7677389">- Controller the activate specific ALU functions</para>
      <list id="id6682352" list-type="bulleted">
        <item>Micro-instruction: Each instruction of the processor is translated into a sequence of lower-level micro-instructions. The process of translation and execution are to as microprogramming</item>
        <item>Microprogramming: The concept of microprogramming was developed by Maurice Wilkes in 1951, using diode matrices for the memory element. A microprogram consist of a sequence of micro-instructions in a microprogramming.</item>
        <item>Microprogrammed Control Unit is a relatively logic circuit that is capable of sequencing through micro-instructions and generating control signal to execute each micro-instruction.</item>
        <item>Control Unit: The control Unit is an important portion of the processor. </item>
      </list>
      <para id="id8790343">The control unit issues control signals external to the processor to cause data echange with memory and I/O unit. The control Unit issues also control signals internal to the processor to move data between registres, to perform the ALU and other internal operations in processor. In a hardwired control unit, the control signals are generated by a micro-instruction are used to controller register transfers and ALU operations. Control Unit design is then the collection and the implementation of all of the needed control signals for the micro-instruction executions.</para>
    </section>
    <section id="id-064015164366">
      <title>2. Control unit design approaches</title>
      <para id="id7448335">How can we use the concept of microprogramming to implement a Control Unit ? There are two approaches of Control Unit Design and implementation:</para>
      <para id="id7448342">- Microprogrammed implementation</para>
      <para id="id7448347">- Hardwired logic implementation</para>
      <para id="id9195628">The figure 7.2 illustrated the control unit inputs. Two techniques have been used to implemente the CU. In a hardwired implementation, the control unit is essentially considered as a logic circuit. Its input logic signals are transformed into the set of ouput logic signals, which are the control signals. The approach of microprogrammed implementation is studied in this section.</para>
      <figure id="id8910753">
        <media id="id1170199980952" alt=""><image src="../../media/graphics1-f295.jpg" mime-type="image/jpeg" height="426" width="578"/></media>
      </figure>
      <para id="id7659708">Figure 7.2 Control unit with decoded inputs</para>
      <section id="id-296100024822">
        <title>2.1 Approach of microprogrammed control unit</title>
        <para id="id7013691">Principe:</para>
        <para id="id7677028">- The control signal values for each microoperation are stored in a memory.</para>
        <para id="id7677034">- Reading the contents of the control store in a prescribed order is equivalent to sequencing through the microoperations</para>
        <para id="id7541486">- Since the “microprogram” of microoperations and their control signal values are stored in memory, this is a microprogrammed unit.</para>
        <para id="id7541495">Remarks:</para>
        <list id="id7368918" list-type="bulleted">
          <item>Are more systematic with a well defined format?</item>
          <item>Can be easily modified during the design process?</item>
          <item>Require more components to implement</item>
          <item>Tend to be slower than hardwired units (due to having to perform memory read operations)</item>
        </list>
      </section>
      <section id="id-385468256374">
        <title>2.2 Approach of hardwired logic</title>
        <para id="id8836581">Principe:</para>
        <para id="id8911204">- The Control Unit is viewed and designed as a combinatorial and sequential logic circuit.</para>
        <para id="id8911210">- The Control Unit is implemented by using any of a variety of “standard” digital logic techniques. The logic circuit generate the fixed sequences of control signals</para>
        <para id="id7676853">- This approach is used to generate fixed sequences of control signals with the higher speed.</para>
        <para id="id8639663">Remarks:</para>
        <list id="id8639667" list-type="bulleted">
          <item>The principle advantages are a high(er) speed operation and the smaller implementations (component counts)</item>
          <item>The modifications to the design can be hard to do</item>
          <item>This approach is favored in RISC style designs</item>
        </list>
      </section>
    </section>
    <section id="id-166299294884">
      <title>3. Microprogrammed Control Unit </title>
      <para id="id8741138">The ideal of microprogrammed Control Unit is that the Control Unit design must include the logics for sequencing through micro-operations, for executing micro-operation, for executing micro-instructions, for interpreting opcodes and for making decision based on ALU flags. So the design is relatively inflexible. It is difficul to change the design if one wishes to add a new machine instruction. </para>
      <para id="id8741149">The principal disadvantage of a microprogrammed control unit is that it will be slower than hardwired unit of comparable technology. Despite this, microprogramming is the dominant technique for implementing control unit in the contemporary CISC processor, due to its ease of implementation.</para>
      <para id="id8911540">The control unit operates by performing consecutive control storage reads to generate the next set of control function outputs. Performing the series of control memory accesses is, in effect, executing a program for each instruction in the machine’s instruction set -- hence the term microprogramming.</para>
      <para id="id8911544">The two basic tasks performed by a microprogrammed control unit are as follows:</para>
      <para id="id8911074">- Micro-instruction sequencing: the microprogrammed control unit get the next mico-instruction from the control memory </para>
      <para id="id8911081">- Micro-instruction execution: the microprogrammed control unit generate the control signals needed to execute the micro-instruction. </para>
      <para id="id8790313">The control unit design must consider both affect the format of the micro-instruction and the timing of the control unit.</para>
      <section id="id-531686962375">
        <title>3.1 Micro-instruction Sequencing</title>
        <para id="id8741072">Two problems are involved in the design of a micro-instruction sequencing technique is the size of micro-instruction and the address-generation time. The first concern is obvious minimizing the size of the control memory. The second concern is simply a desire to execute microinstruction as fast as possible. </para>
        <para id="id7540600">In executing a microprogram, the address of the next microinstruction to be executed is one of these categories:</para>
        <para id="id7540606">- Determined by instruction register</para>
        <para id="id7540610">- Next sequential address</para>
        <para id="id8884386">- Branch. </para>
        <para id="id8884390">It is important to design compact time-efficient techniques for micro-instruction branching.</para>
        <list id="id8741547" list-type="bulleted">
          <item>Sequencing technique</item>
        </list>
        <para id="id8741555">Three general categories for a control memory address are as follows:</para>
        <para id="id8776873">- Two address fields</para>
        <para id="id8776877">- Single address field</para>
        <para id="id8776881">- Variable format</para>
        <para id="id8893932">In Figure 7.3, the branch control logic with a single address field is illustrated.</para>
        <figure id="id8893941">
          <media id="id1170197627170" alt=""><image src="../../media/graphics2-308d.jpg" mime-type="image/jpeg" height="600" width="576"/></media>
        </figure>
        <para id="id9182017">Figure 7.3. Branch Control unit of Microprogrammed Control Unit with with a single address field </para>
        <list id="id7541590" list-type="bulleted">
          <item>Address generation</item>
        </list>
        <para id="id7541602">The problem is to consider the various ways in which the next address can be derived or computed. The various techniques of the address generation is geven in the following.</para>
        <figure id="id9097560">
          <media id="id1170190923699" alt=""><image src="../../media/graphics3-408c.jpg" mime-type="image/jpeg" height="109" width="350"/></media>
        </figure>
        <para id="id8734212">Table 1: Microinstruction Address Generation techiques </para>
      </section>
      <section id="id-39845050564">
        <title>3.2 Micro-instruction Execution</title>
        <para id="id8858000">The microinstruction cycle is the basic event on a microprogrammed processor. Each cycle is made up the two parts: fetch and execute. This section deals with the execution of microinstruction. The effect of the execution of a microinstruction is to generate control signals for both the internal control to processor and the external control to processor.</para>
        <para id="id8858011">A organization of a control unit is shown in Figure 7.4</para>
        <figure id="id8776322">
          <media id="id1170197555144" alt=""><image src="../../media/graphics4-be83.jpg" mime-type="image/jpeg" height="682" width="513"/></media>
        </figure>
        <para id="id8911484">Figure 7.4. Microprogrammed Control Unit Organization</para>
      </section>
    </section>
    <section id="id-862724852134">
      <title>4. Classification of Micro-instructions</title>
      <para id="id8836138">Microinstruction can be classified in variety of ways in which the designer must choose the parallel “power” of each instruction. There are the following.</para>
      <para id="id8836145">– Vertical microprogramming: Each microinstruction specifies a single (or few) microoperations to be performed </para>
      <para id="id8894543">– Horizontal microprogramming: Each microinstruction specifies many different</para>
      <para id="id8894550">microoperations to be performed in parallel.</para>
      <list id="id7430238" list-type="bulleted">
        <item>Vertical microprogramming</item>
      </list>
      <para id="id8835978">– Width is narrow: n control signals can be encoded into log2n control bits</para>
      <para id="id8835988">– Limited ability to express parallelism</para>
      <para id="id8857059">– Considerable encoding of control information requires external memory word decoder to identify the exact control line being manipulated</para>
      <list id="id8748573" list-type="bulleted">
        <item>Horizontal microprogramming</item>
      </list>
      <para id="id8776597">– Wide memory word</para>
      <para id="id8776606">– High degree of parallel operations are possible</para>
      <para id="id8218278">– Little to no encoding of control information</para>
      <list id="id8776652" list-type="bulleted">
        <item>Compromise technique</item>
      </list>
      <para id="id8911298">– Divide control signals into disjoint groups</para>
      <para id="id8911307">– Implement each group as a separate field in the memory word</para>
      <para id="id8174415">– Supports reasonable levels of parallelism without too much complexity</para>
      <list id="id8458675" list-type="bulleted">
        <item>Second compromise: nanoprogramming</item>
      </list>
      <para id="id8458683">– Use a 2-level control storage organization</para>
      <para id="id8755591">– Top level is a vertical format memory</para>
      <para id="id8755596">Output of the top level memory drives the address register of the bottom (nano-level) memory</para>
      <para id="id7677896">– Nanomemory uses the horizontal formal. The produces the actual control signal outputs</para>
      <para id="id8734382">– The advantage to this approach is significant saving in control memory size (bits)</para>
      <para id="id8755614">– Disadvantage is more complexity and slower operation (doing 2 memory accesses fro each microinstruction).</para>
      <list id="id8755622" list-type="bulleted">
        <item>Microprogramming applications </item>
      </list>
      <para id="id9141349">- For the typically large microprocessor systems today:</para>
      <para id="id8741192">+ There are many instructions and associated register level hardware</para>
      <para id="id8741198">+ There are many control point to be manipulated.</para>
      <para id="id8836641">- Emulation</para>
      <para id="id8836650">– The use of a microprogram on one machine to execute programs originally written to run on another machine.</para>
      <para id="id8911280">– By changing the microcode of a machine, you can make it execute software from another machine.</para>
    </section>
  </content>
</document>